/// SPDX-License-Identifier: AGPL-3.0
pragma solidity ^0.8.23;

import {SafeTransferLib} from "@solmate/utils/SafeTransferLib.sol";
import {Owned} from "@solmate/auth/Owned.sol";
import {FixedPointMathLib} from "@solady/utils/FixedPointMathLib.sol";
import {ReentrancyGuard} from "@solmate/utils/ReentrancyGuard.sol";

import {ITruglyFactory} from "./interfaces/ITruglyFactory.sol";
import {IWETH9} from "./interfaces/external/IWETH9.sol";
import {IMEME404} from "./interfaces/IMEME404.sol";
import {IMEME20} from "./interfaces/IMEME20.sol";
import {Constant} from "./libraries/Constant.sol";
import {MEME20Constant} from "./libraries/MEME20Constant.sol";
import {ILiquidityLocker} from "./interfaces/external/ILiquidityLocker.sol";
import {INonfungiblePositionManager} from "./interfaces/external/INonfungiblePositionManager.sol";
import {ITruglyMemeception} from "./interfaces/ITruglyMemeception.sol";
import {IUniswapV3Factory} from "./interfaces/external/IUniswapV3Factory.sol";
import {IUniswapV3Pool} from "./interfaces/external/IUniswapV3Pool.sol";
import {ITruglyVesting} from "./interfaces/ITruglyVesting.sol";

/// @title The interface for the Trugly Fair Launch
/// @notice This contract is in charge of creating MEME20 & MEME404 and their fair launch
/// @notice Contract generated by https://www.trugly.meme
contract TruglyMemeception is ITruglyMemeception, Owned, ReentrancyGuard {
    using FixedPointMathLib for uint256;
    using SafeTransferLib for address;

    /* ¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯*/
    /*                       EVENTS                      */
    /* ¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯*/

    /// @dev Emitted when a MEME20 is created
    event MemeCreated(address indexed memeToken, address pool, ITruglyMemeception.MemeceptionCreationParams params);

    /// @dev Emitted when a MEMEKOL is created
    event MemeKOLCreated(address indexed memeToken, address pool, ITruglyMemeception.MemeceptionCreationParams params);

    /// @dev Emitted when a MEME404 is created
    event Meme404Created(
        address indexed memeToken,
        address pool,
        ITruglyMemeception.MemeceptionCreationParams params,
        IMEME404.TierCreateParam[] tiers
    );

    /// @dev Emitted when a user buy memecoins in the fair launch
    event MemecoinBuy(address indexed memeToken, address indexed user, uint256 amountETH, uint256 amountMeme);

    /// @dev Emitted when liquidity has been added to the UniV3 Pool
    event MemeLiquidityAdded(address indexed memeToken, address pool, uint256 amountMeme, uint256 amountETH);

    /// @dev Emitted when a user exits the fair launch and claims a refund
    event MemecoinExit(address indexed memeToken, address indexed user, uint256 amountETH, uint256 amountMeme);

    /// @dev Emited when the treasury is updated
    event TreasuryUpdated(address indexed oldTreasury, address indexed newTreasury);

    /// @dev Emitted when the fees are collected
    event CollectFees(
        address indexed memeToken,
        address indexed recipient,
        uint256 amount0,
        uint256 amount1,
        uint256 fee0,
        uint256 fee1
    );

    /* ¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯*/
    /*                       ERRORS                      */
    /* ¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯*/

    /// @dev Invalid Meme Address (has to be > WETH9)
    error InvalidMemeAddress();

    /// @dev Thrown when the swap fee is too high
    error MemeSwapFeeTooHigh();

    /// @dev Thrown when the vesting allocation is too high
    error VestingAllocTooHigh();

    /// @dev Thrown when the memeceptions ended and the Meme pool is launched
    error MemeLaunched();

    /// @dev Thrown when the Memeception has not started
    error MemeceptionNotStarted();

    /// @dev Thrown when address is address(0)
    error ZeroAddress();

    /// @dev Thrown when the amount is 0
    error ZeroAmount();

    /// @dev Thrown when the amount > MAX_TARGET_ETH
    error MaxTargetETH();

    /// @dev Thrown when the Locker fees is too high
    error LockerFeeTooHigh();

    /// @dev Thrown when the Locker fee structure is invalid
    error InvalidLockerFeeStructure();

    /* ¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯*/
    /*                       STORAGE                     */
    /* ¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯*/
    /// @dev Address of the UniswapV3 Factory
    IUniswapV3Factory public immutable v3Factory = IUniswapV3Factory(Constant.UNISWAP_BASE_V3_FACTORY);

    /// @dev Address of the UniswapV3 NonfungiblePositionManager
    INonfungiblePositionManager public immutable v3PositionManager =
        INonfungiblePositionManager(Constant.UNISWAP_BASE_V3_POSITION_MANAGER);

    /// @dev Address of the UNCX Locker
    ILiquidityLocker public immutable uncxLocker = ILiquidityLocker(Constant.UNCX_BASE_V3_LOCKERS);

    /// @dev Address of the WETH9 contract
    IWETH9 public immutable WETH9 = IWETH9(Constant.BASE_WETH9);

    /// @dev Vesting contract for MEME20 tokens
    ITruglyVesting public immutable vesting;

    /// @dev Mapping of memeToken => memeceptions
    mapping(address => Memeception) internal memeceptions;

    address[] internal SWAP_ROUTERS = [Constant.UNISWAP_BASE_SWAP_ROUTER, Constant.UNISWAP_BASE_UNIVERSAL_ROUTER];

    address[] internal EXEMPT_FEES = [
        Constant.UNISWAP_BASE_STAKER_ADDRESS,
        Constant.UNISWAP_BASE_FEE_COLLECTOR,
        Constant.UNISWAP_BASE_V3_POSITION_MANAGER,
        Constant.UNCX_BASE_V3_LOCKERS,
        Constant.TRUGLY_BASE_UNIVERSAL_ROUTER
    ];

    address internal treasury;

    address public immutable factory;

    constructor(address _vesting, address _treasury, address _multisig, address _factory) Owned(_multisig) {
        if (_vesting == address(0) || _treasury == address(0) || _factory == address(0) || _multisig == address(0)) {
            revert ZeroAddress();
        }
        v3PositionManager.setApprovalForAll(address(uncxLocker), true);

        vesting = ITruglyVesting(_vesting);
        treasury = _treasury;
        factory = _factory;

        emit TreasuryUpdated(address(0), _treasury);
    }

    /// @inheritdoc ITruglyMemeception
    function createMeme(MemeceptionCreationParams calldata params) external nonReentrant returns (address, address) {
        _verifyCreateMeme(params);
        address memeToken =
            ITruglyFactory(factory).createMeme20(params.name, params.symbol, params.creator, params.salt);
        address pool = v3Factory.createPool(address(WETH9), address(memeToken), Constant.UNI_LP_SWAPFEE);
        _createMeme(params, memeToken, pool);
        emit MemeCreated(address(memeToken), pool, params);
        return (address(memeToken), pool);
    }

    /// @inheritdoc ITruglyMemeception
    function createMemeKOL(MemeceptionCreationParams calldata params)
        external
        nonReentrant
        returns (address, address)
    {
        _verifyCreateMeme(params);
        address memeToken =
            ITruglyFactory(factory).createMeme20(params.name, params.symbol, params.creator, params.salt);
        address pool = v3Factory.createPool(address(WETH9), address(memeToken), Constant.UNI_LP_SWAPFEE);
        _createMeme(params, memeToken, pool);
        emit MemeKOLCreated(address(memeToken), pool, params);
        return (address(memeToken), pool);
    }

    /// @inheritdoc ITruglyMemeception
    function createMeme404(MemeceptionCreationParams calldata params, IMEME404.TierCreateParam[] calldata tiers)
        external
        nonReentrant
        returns (address, address)
    {
        _verifyCreateMeme(params);
        address memeToken =
            ITruglyFactory(factory).createMeme404(params.name, params.symbol, params.creator, params.salt);
        address pool = v3Factory.createPool(address(WETH9), address(memeToken), Constant.UNI_LP_SWAPFEE);

        /// List of exempt addresses for MEME404 NFT minting
        address[] memory exemptNFTMint = new address[](5 + SWAP_ROUTERS.length + EXEMPT_FEES.length);
        exemptNFTMint[0] = address(this);
        exemptNFTMint[1] = address(vesting);
        exemptNFTMint[2] = address(treasury);
        exemptNFTMint[3] = pool;
        exemptNFTMint[4] = params.creator;

        for (uint256 i = 0; i < SWAP_ROUTERS.length; i++) {
            exemptNFTMint[i + 5] = SWAP_ROUTERS[i];
        }

        for (uint256 i = 0; i < EXEMPT_FEES.length; i++) {
            exemptNFTMint[i + 5 + SWAP_ROUTERS.length] = EXEMPT_FEES[i];
        }
        IMEME404(memeToken).initializeTiers(tiers, exemptNFTMint);

        _createMeme(params, memeToken, pool);
        emit Meme404Created(address(memeToken), pool, params, tiers);
        return (address(memeToken), pool);
    }

    /// @dev Create a memecoin and memeception params
    /// @dev Also initialize the vesting
    /// @param params List of parameters for the creation of a memeception
    /// @param memeToken Address of the MEME20 or MEME404
    function _createMeme(MemeceptionCreationParams calldata params, address memeToken, address pool) internal {
        if (memeToken <= address(WETH9)) revert InvalidMemeAddress();

        uint40 startAt = params.startAt > uint40(block.timestamp) ? params.startAt : uint40(block.timestamp);

        memeceptions[memeToken] = Memeception({
            targetETH: params.targetETH,
            collectedETH: 0,
            tokenId: 0,
            pool: pool,
            swapFeeBps: params.swapFeeBps,
            creator: params.creator,
            startAt: startAt,
            endedAt: 0
        });

        if (params.vestingAllocBps > 0) {
            uint256 vestingAlloc = MEME20Constant.TOKEN_TOTAL_SUPPLY.fullMulDiv(params.vestingAllocBps, 1e4);
            IMEME20(memeToken).transfer(address(vesting), vestingAlloc);
            vesting.startVesting(
                address(memeToken),
                params.creator,
                vestingAlloc,
                startAt,
                Constant.VESTING_DURATION,
                Constant.VESTING_CLIFF
            );
        }
        uint256 burnAllocBps = Constant.CREATOR_MAX_VESTED_ALLOC_BPS - params.vestingAllocBps;
        if (burnAllocBps > 0) {
            IMEME20(memeToken).transfer(address(0), MEME20Constant.TOKEN_TOTAL_SUPPLY.fullMulDiv(burnAllocBps, 1e4));
        }

        uint160 sqrtPriceX96 =
            _calcSqrtPriceX96(params.targetETH - _getUncxLockerFee(), Constant.TOKEN_MEMECEPTION_SUPPLY);
        IUniswapV3Pool(memeceptions[memeToken].pool).initialize(sqrtPriceX96);
    }

    /// @dev Verify the validity of the parameters for the creation of a memeception
    /// @param params List of parameters for the creation of a memeception
    /// Revert if any parameters are invalid
    function _verifyCreateMeme(MemeceptionCreationParams calldata params) internal pure {
        if (params.swapFeeBps > MEME20Constant.MAX_CREATOR_FEE_BPS) revert MemeSwapFeeTooHigh();
        if (params.vestingAllocBps > Constant.CREATOR_MAX_VESTED_ALLOC_BPS) revert VestingAllocTooHigh();
        if (params.targetETH == 0) revert ZeroAmount();
        if (params.targetETH > Constant.MAX_TARGET_ETH) revert MaxTargetETH();
    }

    /// @inheritdoc ITruglyMemeception
    function buyMemecoin(address memeToken) external payable nonReentrant {
        Memeception memory memeception = memeceptions[memeToken];
        if (msg.value == 0) revert ZeroAmount();
        if (memeception.endedAt > 0) revert MemeLaunched();
        if (uint40(block.timestamp) < memeception.startAt) revert MemeceptionNotStarted();

        uint256 price = _getPricePerETH(memeception);

        uint256 buyEthAmount = msg.value;
        uint256 tokenAmount = buyEthAmount.rawMul(price);

        if (memeception.collectedETH + msg.value >= memeception.targetETH) {
            buyEthAmount = memeception.targetETH.rawSub(memeception.collectedETH);

            memeceptions[memeToken].endedAt = uint40(block.timestamp);

            tokenAmount = buyEthAmount.rawMul(price);

            /// Adding liquidity to Uni V3 Pool
            _addLiquidityToUniV3Pool(memeToken, memeception.targetETH, Constant.TOKEN_MEMECEPTION_SUPPLY);

            // Refund
            msg.sender.safeTransferETH(msg.value - buyEthAmount);
        }

        memeceptions[memeToken].collectedETH += buyEthAmount;
        IMEME20(memeToken).transfer(msg.sender, tokenAmount);

        emit MemecoinBuy(memeToken, msg.sender, buyEthAmount, tokenAmount);
    }

    /// @dev Add liquidity to the UniV3 Pool and initialize the pool
    /// @param memeToken Address of the MEME20
    /// @param amountETH Amount of ETH to add to the pool
    /// @param amountMeme Amount of IMEME20 to add to the pool
    function _addLiquidityToUniV3Pool(address memeToken, uint256 amountETH, uint256 amountMeme) internal {
        uint256 uncxLockFee = _getUncxLockerFee();
        uint256 amountETHMinusLockFee = amountETH - uncxLockFee;

        IMEME20(memeToken).initialize(
            owner,
            treasury,
            MEME20Constant.MAX_PROTOCOL_FEE_BPS,
            memeceptions[memeToken].swapFeeBps,
            memeceptions[memeToken].pool,
            SWAP_ROUTERS,
            EXEMPT_FEES
        );

        WETH9.deposit{value: amountETHMinusLockFee}();
        WETH9.approve(address(v3PositionManager), amountETHMinusLockFee);
        IMEME20(memeToken).approve(address(v3PositionManager), amountMeme);

        INonfungiblePositionManager.MintParams memory params = INonfungiblePositionManager.MintParams({
            token0: address(WETH9),
            token1: memeToken,
            fee: Constant.UNI_LP_SWAPFEE,
            tickLower: Constant.TICK_LOWER,
            tickUpper: Constant.TICK_UPPER,
            amount0Desired: amountETHMinusLockFee,
            amount1Desired: amountMeme,
            amount0Min: amountETHMinusLockFee.mulDiv(99, 100),
            amount1Min: amountMeme.mulDiv(99, 100),
            recipient: address(this),
            deadline: block.timestamp + 30 minutes
        });

        (uint256 tokenId,,,) = v3PositionManager.mint(params);

        uint256 lockId = _lockLiquidity(tokenId, uncxLockFee);
        memeceptions[memeToken].tokenId = lockId;

        emit MemeLiquidityAdded(memeToken, memeceptions[memeToken].pool, amountMeme, amountETHMinusLockFee);
    }

    /// @dev Lock the UniV3 liquidity in the UNCX Locker
    /// @param lpTokenId The UniV3 LP Token ID
    /// @return lockId The UNCX lock ID
    function _lockLiquidity(uint256 lpTokenId, uint256 lockFee) internal virtual returns (uint256 lockId) {
        lockId = uncxLocker.lock{value: lockFee}(
            ILiquidityLocker.LockParams({
                nftPositionManager: v3PositionManager,
                nft_id: lpTokenId,
                dustRecipient: treasury,
                owner: owner,
                additionalCollector: address(this),
                collectAddress: treasury,
                unlockDate: type(uint256).max,
                countryCode: 0,
                feeName: "LVP",
                r: new bytes[](0)
            })
        );
    }

    function _getUncxLockerFee() internal view virtual returns (uint256) {
        ILiquidityLocker.FeeStruct memory lockFee = uncxLocker.getFee("LVP");
        if (lockFee.flatFee > 0 && lockFee.flatFeeToken != address(0)) revert InvalidLockerFeeStructure();
        if (lockFee.lpFee > Constant.MAX_LOCKER_LP_FEE || lockFee.collectFee > Constant.MAX_LOCKER_COLLECT_FEE) {
            revert InvalidLockerFeeStructure();
        }
        if (lockFee.flatFee > 0 && lockFee.flatFeeToken == address(0)) {
            if (lockFee.flatFee > Constant.MAX_LOCKER_FLAT_FEE) revert LockerFeeTooHigh();
            return lockFee.flatFee;
        }
        return 0;
    }

    /// @inheritdoc ITruglyMemeception
    function exitMemecoin(address memeToken, uint256 amountMeme) external nonReentrant {
        Memeception memory memeception = memeceptions[memeToken];
        if (memeception.startAt == 0) revert InvalidMemeAddress();
        if (memeception.endedAt > 0) revert MemeLaunched();

        uint256 price = _getPricePerETH(memeception);
        IMEME20(memeToken).transferFrom(msg.sender, address(this), amountMeme);
        uint256 refundAmount = amountMeme.rawDiv(price);

        memeceptions[memeToken].collectedETH -= refundAmount;
        msg.sender.safeTransferETH(refundAmount);

        emit MemecoinExit(memeToken, msg.sender, refundAmount, amountMeme);
    }

    /// @inheritdoc ITruglyMemeception
    function collectFees(address memeToken) external nonReentrant {
        if (memeceptions[memeToken].tokenId == 0) revert InvalidMemeAddress();
        (uint256 amount0, uint256 amount1, uint256 fee0, uint256 fee1) =
            uncxLocker.collect(memeceptions[memeToken].tokenId, treasury, type(uint128).max, type(uint128).max);
        emit CollectFees(memeToken, treasury, amount0, amount1, fee0, fee1);
    }

    function _calcSqrtPriceX96(uint256 supplyA, uint256 supplyB) internal pure returns (uint160) {
        // Calculate the price ratio (supplyB / supplyA)
        uint256 priceRatio = FixedPointMathLib.fullMulDiv(supplyB, 1e32, supplyA);

        // Calculate the square root of the price ratio
        uint256 sqrtRatio = FixedPointMathLib.sqrt(priceRatio);

        // Convert to Q64.96 format
        return uint160(FixedPointMathLib.fullMulDiv(sqrtRatio, 2 ** 96, FixedPointMathLib.sqrt(1e32)));
    }

    /// @inheritdoc ITruglyMemeception
    function getMemeception(address memeToken) external view returns (Memeception memory) {
        return memeceptions[memeToken];
    }

    /// @inheritdoc ITruglyMemeception
    function getPricePerETH(address memeToken) public view returns (uint256) {
        Memeception memory memeception = memeceptions[memeToken];
        return _getPricePerETH(memeception);
    }

    function _getPricePerETH(Memeception memory memeception) internal pure returns (uint256) {
        return Constant.TOKEN_MEMECEPTION_SUPPLY.rawDiv(memeception.targetETH);
    }

    /// @notice receive native tokens
    receive() external payable {}

    /// @dev receive ERC721 tokens for Univ3 LP Positions
    function onERC721Received(address, address, uint256, bytes calldata) external pure returns (bytes4) {
        return this.onERC721Received.selector;
    }

    /// @notice Only the owner can call this function
    /// @dev Update the treasury address
    /// @param _newTreasury The new treasury address
    function setTreasury(address _newTreasury) external onlyOwner {
        if (_newTreasury == address(0)) revert ZeroAddress();
        emit TreasuryUpdated(treasury, _newTreasury);
        treasury = _newTreasury;
    }
}
